#!/usr/bin/env python3
"""
Module to add GO annotations and re-map them to a desired depth.
"""

import numpy as np


def annotate_GO(interaction_dataframe, gaf_dict, columns=None):
    """ Adds Gene Ontology terms to interaction dataset.

        Creates separate columns with Gene Ontology terms for both interaction
        partners in the interaction DataFrame.
        NOTE: the UniProt ACs need to be formatted to remove potential
              PTM labels, e.g. P04295-PRO_0000115940. This is what the
              regex accomplishes.

        Parameters
        ----------
        interaction_dataframe : DataFrame
            The pandas DataFrame containing the protein-protein interactions
            to be labelled.

        gaf_dict : dictionary
            A dictionary mapping UniProt ACs to Gene Ontology terms.

        Returns
        -------
        None
            Modifies the interaction dataframe in-place by adding Gene
            Ontology columns: ['GO_A', 'GO_B']
        """
    if not columns:
        columns = ['xref_A', 'xref_B']

    for i in columns:
        interaction_dataframe['GO_' + i] = interaction_dataframe[i].str.extract(
            '^.*:(\w*)-?',
            expand=False).apply(lambda x: gaf_dict.get(x, np.NaN))

    # alternative:
    # interaction_dataframe['GO_A'] = interaction_dataframe['xref_A'].apply(lambda x: gaf_dict.get(x.split(':')[1]))
    # or:
    # interaction_dataframe['GO_A'] = interaction_dataframe[
    #     'xref_A'].str.extract(
    #         '^.*:(\w*)-?',
    #         expand=False).apply(lambda x: gaf_dict.get(x, np.NaN))
    # map(gaf_dict) instead of apply should work as well,
    # automatically assigns NaNs.


def remap_GO_depth(interaction_dataframe,
                   depth,
                   go_dict,
                   test_set_not,
                   test_set_in,
                   exception_list=None,
                   GO_columns=None):
    """Remaps the GO terms in an interaction dataframe to their ancestor terms
    of the desired depth of the GO hierarchy.

    Goes through the GO term sets in the provided columns (default "GO_A" and 
    "GO_B") of an interaction DataFrame and retrieves their ancestor GO terms
    of the specified depth, as a set.
    Only remaps the terms belonging to the given namespace.
    NOTE: terms with an initial depth that is lower than the chosen depth will
          be retained as is.

    Parameters
    ----------
    interaction_dataframe : DataFrame
        The pandas DataFrame containing the protein-protein interactions and
        associated GO terms.
    # depth : int
    #     The depth to which to map the GO terms.
    depth : dict
        The depth to which to map the GO terms for each namespace.
    go_dict : dict
        A dictionary of GO objects generated by importOBO().
        Keys are of the format "GO:0000001" and map to goTerm objects.
    # namespace: str
    #     The namespace to which the GO terms must belong if they are to be
    #     remapped.
    #     TODO: alternatively, provide a dictionary so this can happen in
    #           one pass...
    exception_list : list
        A list containing GO term IDs that should be ignored (i.e. their
        tracker child should be retained instead).
        (Default: None, which sets it to an empty list.)
    GO_columns : list
        A list of columns that contain the GO sets.
        (Default value is None, which leads to ['GO_A', 'GO_B']).

    Returns
    -------
    None
        Modifies the interaction dataframe in-place by replacing the GO sets
        in the GO_columns Gene Ontology columns.
    """
    if GO_columns is None:
        GO_columns = ['GO_A', 'GO_B']
    for i in GO_columns:
        interaction_dataframe.loc[interaction_dataframe[i].notnull(), i] = \
            interaction_dataframe.loc[interaction_dataframe[i].notnull()].apply(
                lambda x: _remap_GO_apply_row_operation(x[i], depth, go_dict, exception_list, test_set_not, test_set_in), axis=1)


def _remap_GO_apply_row_operation(GO_set, depth, go_dict, exception_list,
                                  test_set_not, test_set_in):
    """Remaps all the GO terms in a set to their ancestors of the specified
    depth.

    All the GO terms in a set, e.g. those in a specific row of a pandas Series
    accessed through apply, are mapped to their ancestor nodes of a specified
    depth and returned as a set.
    More specifically, for each term map_to_depth() is called and the results
    are added to a set.

    Parameters
    ----------
    GO_set : set
        A set of GO terms of the format "GO:0000001".
    # depth : int
    #     The depth to which to map
    depth : dict
        The depth to which to map the GO terms for each namespace.
    go_dict : dict
        A dictionary of GO objects generated by importOBO().
        Keys are of the format "GO:0000001" and map to goTerm objects.
    exception_list : list
        A list containing GO term IDs that should be ignored (i.e. their
        tracker child should be retained instead).
        (Default: None, which sets it to an empty list.)

    Returns
    -------
    set
        A set of GO terms of the specified depth that are ancestors of the 
        initial terms in the set.

    """

    # Define a new set to collect all remapped terms of the desired depth.
    remapped_nodes = set()
    # For each GO term on the current row, i.e. associated with the protein in the corresponding xref column
    for GO_term in GO_set:
        # check if term is present in dictionary
        if GO_term in go_dict:
            # check if the term has a lower depth already...
            if go_dict.get(GO_term).depth < depth.get(
                    go_dict.get(GO_term).namespace):
                # ...and add it to the remapped set if this is the case. Removing this line would omit the term.
                # unless it is in the exception list
                if GO_term not in exception_list:
                    print(
                        'GO term {} was not in the exception list and will be added as is due to lower depth!'.
                        format(GO_term))
                    remapped_nodes.add(
                        GO_term
                    )  # these terms make up a substantial amount of terms, depending on the depth limit
                    test_set_not.append(
                        GO_term
                    )  # but they are relatively uninformative and will likely be filtered out later...again depending on the depth
                    # Note that without the 'if not in exclusion' check this might add a term in the exclusion list,
                    # but there is no way to remap it back to a more specific term since it's the base call prior
                    # to any recursive climb...
                else:
                    print(
                        'GO term {} was in the exception list and won\' be mapped upwards!'.
                        format(GO_term))
                    test_set_in.append(GO_term)
            # retrieve all parent terms of the desired depth
            _map_node_to_depth(GO_term, depth, go_dict, remapped_nodes,
                               exception_list)
            # remapped_nodes.update(map_to_depth(GO_term, depth, go_dict, None))
        else:
            print(f'WARNING: {GO_term} not found in GO dictionary.')
    return remapped_nodes


def _map_node_to_depth(node,
                       depth,
                       go_dict,
                       found_nodes,
                       exception_list=None,
                       tracker=None):
    """Remaps a GO term to its ancestor terms of the specified depth using
    recursion.

    Starting from the supplied node, a recursive search will collect the
    ancestral nodes of the desired depth and add them to the growing
    found_nodes set. Depending on the use case, this set should initially be
    supplied as an empty set.
    NOTE: a GO term can have multiple parents with a lower depth.
    NOTE: an exception list can be provided. Whenever a term is mapped to an
          ID in this list, the ID is not saved, but its previous caller
          (tracker) is collected instead.

    Parameters
    ----------
    node : str
        A GO term of the format "GO:0000001"
    # depth : int
    #     The depth to which to map.
    depth : dict
        The depth to which to map the GO terms for each namespace.
    go_dict : dict
        A dictionary of GO objects generated by importOBO().
        Keys are of the format "GO:0000001" and map to goTerm objects.
    found_nodes : set
        A set that is grown throughout the recursion by adding the ancestral
        nodes of the desired depth.
    exception_list : list
        A list containing GO term IDs that should be ignored (i.e. their
        tracker child should be retained instead).
        (Default: None, which sets it to an empty list.)
    tracker : str
        Tracks the previous node that called the current iteration of the
        recursion.

    Returns
    -------
    None
        The found_nodes set is updated throughout the recursion. It should be
        defined before calling this function and passed to it in order to be
        available for use afterwards.
    # set
    #     A set of GO terms of the specified depth that are ancestors of the
    #     initial node.

    """
    # # check if GO term belongs to the chosen namespace
    #     # TODO: how will this react to full obo dictionaries where part_of was retained?
    #     # TODO: in that case, the check should happen again for each recursion of map_node_to_depth()
    # if go_dict.get(node).namespace == namespace:

    # if go_dict.get(node).depth == depth: #TODO change this
    #     found_nodes.add(node)

    if exception_list is None:
        exception_list = []

    # Check if go_term is present in dictionary and end recursion otherwise to avoid bad dictionary calls
    if node not in go_dict:
        print(
            f'WARNING: {node} not found in GO dictionary during depth remapping!'
        )
        return None
    # Retrieve goTerm object for current node
    go_term = go_dict.get(node)
    # If the current node is in the exception list, end recursion and add its child term (i.e. the caller).
    # Must be checked prior to depth check, otherwise passing of a base term of depth+1 in exclusion list
    # would call its parent which would be excluded and it would add its tracker, the depth+1 exclusion.
    if node in exception_list:
        if tracker:
            found_nodes.add(tracker)
        # else: # if there is no tracker, don't add the note itself since it's in the exclusion list
        #     found_nodes.add(node) # however, due to the frequent item set mining it wouldn't matter much
        return None  # since it's likely a rare term...
    else:
        # If the current node has the specified depth (for its namespace), add it to the new set of nodes.
        if go_term.depth == depth.get(go_term.namespace):
            found_nodes.add(node)
        # Next, recurse the function for all of its parent nodes.
        # Don't use else clause because some nodes might have the same depth as their parents.
        # An else clause would stop the recursion prematurely and omit these ancestors from the final set.
        for parent in go_term.parents:
            _map_node_to_depth(parent, depth, go_dict, found_nodes,
                               exception_list, node)
            # # Return the set of remapped terms after recursion is finished.
            # return found_nodes
        '''

    if exception_list is None:
        exception_list = []

    # Check if go_term is present in dictionary and end recursion otherwise to avoid bad dictionary calls
    if node not in go_dict:
        print(f'WARNING: {node} not found in GO dictionary during depth remapping!')
        return None
    # Retrieve goTerm object for current node
    go_term = go_dict.get(node)
    # If the current node has the specified depth (for its namespace), add it to the new set of nodes.
    if go_term.depth == depth.get(go_term.namespace):
        # unless the term belongs to the exception list, in which case, add its child term (i.e. the caller).
        if node in exception_list:
            # if it exists
            if tracker:
                found_nodes.add(tracker)
        else:
            found_nodes.add(node)
    # Next, recurse the function for all of its parent nodes.
    # Don't use else clause because some nodes might have the same depth as their parents.
    # An else clause would stop the recursion prematurely and omit these ancestors from the final set.
    for parent in go_term.parents:
        map_node_to_depth(parent, depth, go_dict, found_nodes, exception_list, node)
        # # Return the set of remapped terms after recursion is finished.
        # return found_nodes

        '''
